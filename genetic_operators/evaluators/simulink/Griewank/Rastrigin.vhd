-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc/Griewank/Rastrigin.vhd
-- Created: 2021-07-14 22:58:23
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Rastrigin
-- Source Path: Griewank/Rastrigin
-- Hierarchy Level: 0
-- 
-- Simulink subsystem description for Griewank/Rastrigin:
-- 
-- This block was created using function approximation.
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Rastrigin_pkg.ALL;

ENTITY Rastrigin IS
  PORT( In1                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        In3                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
        Out1                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En10
        );
END Rastrigin;


ARCHITECTURE rtl OF Rastrigin IS

  -- Constants
  CONSTANT LUT_data                       : vector_of_signed16(0 TO 10) := 
    (to_signed(16#1228#, 16), to_signed(-16#29D5#, 16), to_signed(-16#3F5C#, 16), to_signed(-16#1AA2#, 16),
     to_signed(16#2294#, 16), to_signed(16#4000#, 16), to_signed(16#2294#, 16), to_signed(-16#1AA2#, 16),
     to_signed(-16#3F5C#, 16), to_signed(-16#29D5#, 16), to_signed(16#1228#, 16));  -- sfix16 [11]
  CONSTANT LUT1_data                      : vector_of_signed16(0 TO 10) := 
    (to_signed(16#1228#, 16), to_signed(-16#29D5#, 16), to_signed(-16#3F5C#, 16), to_signed(-16#1AA2#, 16),
     to_signed(16#2294#, 16), to_signed(16#4000#, 16), to_signed(16#2294#, 16), to_signed(-16#1AA2#, 16),
     to_signed(-16#3F5C#, 16), to_signed(-16#29D5#, 16), to_signed(16#1228#, 16));  -- sfix16 [11]

  -- Signals
  SIGNAL In1_signed                       : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL Product3_mul_temp                : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL Product3_out1                    : unsigned(15 DOWNTO 0);  -- ufix16_En9
  SIGNAL In3_signed                       : signed(15 DOWNTO 0);  -- sfix16_En10
  SIGNAL Product2_mul_temp                : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL Product2_out1                    : unsigned(15 DOWNTO 0);  -- ufix16_En9
  SIGNAL Constant1_out1                   : unsigned(15 DOWNTO 0);  -- ufix16_En10
  SIGNAL Constant3_out1                   : unsigned(15 DOWNTO 0);  -- ufix16_En4
  SIGNAL Divide1_out1                     : unsigned(15 DOWNTO 0);  -- ufix16_En5
  SIGNAL Constant6_out1                   : unsigned(15 DOWNTO 0);  -- ufix16_En4
  SIGNAL Divide2_out1                     : unsigned(15 DOWNTO 0);  -- ufix16_En5
  SIGNAL Add1_add_cast                    : unsigned(31 DOWNTO 0);  -- ufix32_En5
  SIGNAL Add1_add_cast_1                  : unsigned(31 DOWNTO 0);  -- ufix32_En5
  SIGNAL Add1_add_temp                    : unsigned(31 DOWNTO 0);  -- ufix32_En5
  SIGNAL Add1_out1                        : unsigned(15 DOWNTO 0);  -- ufix16_En10
  SIGNAL Data_Type_Conversion_out1        : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL LUT_out1                         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Divide_out1                      : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion1_out1       : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL LUT1_out1                        : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_mul_temp                 : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_out1                     : signed(15 DOWNTO 0);  -- sfix16_En13
  SIGNAL Add_stage2_sub_cast              : signed(31 DOWNTO 0);  -- sfix32_En13
  SIGNAL Add_stage2_sub_cast_1            : signed(31 DOWNTO 0);  -- sfix32_En13
  SIGNAL Add_op_stage2                    : signed(31 DOWNTO 0);  -- sfix32_En13
  SIGNAL Constant5_out1                   : unsigned(15 DOWNTO 0);  -- ufix16_En10
  SIGNAL Add_stage3_add_cast              : signed(31 DOWNTO 0);  -- sfix32_En13
  SIGNAL Add_stage3_add_temp              : signed(31 DOWNTO 0);  -- sfix32_En13
  SIGNAL Add_out1                         : signed(15 DOWNTO 0);  -- sfix16_En10

BEGIN
  In1_signed <= signed(In1);

  Product3_mul_temp <= In1_signed * In1_signed;
  Product3_out1 <= unsigned(Product3_mul_temp(26 DOWNTO 11));

  In3_signed <= signed(In3);

  Product2_mul_temp <= In3_signed * In3_signed;
  Product2_out1 <= unsigned(Product2_mul_temp(26 DOWNTO 11));

  Constant1_out1 <= to_unsigned(16#05A8#, 16);

  Constant3_out1 <= to_unsigned(16#FA00#, 16);

  Divide1_output : PROCESS (Constant3_out1, Product3_out1)
    VARIABLE div_temp : unsigned(15 DOWNTO 0);
  BEGIN
    IF Constant3_out1 = to_unsigned(16#0000#, 16) THEN 
      Divide1_out1 <= to_unsigned(16#FFFF#, 16);
    ELSE 
      div_temp := Product3_out1 / Constant3_out1;
      Divide1_out1 <= div_temp;
    END IF;
  END PROCESS Divide1_output;


  Constant6_out1 <= to_unsigned(16#FA00#, 16);

  Divide2_output : PROCESS (Constant6_out1, Product2_out1)
    VARIABLE div_temp1 : unsigned(15 DOWNTO 0);
  BEGIN
    IF Constant6_out1 = to_unsigned(16#0000#, 16) THEN 
      Divide2_out1 <= to_unsigned(16#FFFF#, 16);
    ELSE 
      div_temp1 := Product2_out1 / Constant6_out1;
      Divide2_out1 <= div_temp1;
    END IF;
  END PROCESS Divide2_output;


  Add1_add_cast <= resize(Divide1_out1, 32);
  Add1_add_cast_1 <= resize(Divide2_out1, 32);
  Add1_add_temp <= Add1_add_cast + Add1_add_cast_1;
  Add1_out1 <= Add1_add_temp(10 DOWNTO 0) & '0' & '0' & '0' & '0' & '0';

  Data_Type_Conversion_out1 <= In1_signed(13 DOWNTO 0) & '0' & '0';

  LUT_output : PROCESS (Data_Type_Conversion_out1)
    VARIABLE dout_low : signed(15 DOWNTO 0);
    VARIABLE k : unsigned(3 DOWNTO 0);
    VARIABLE f : unsigned(31 DOWNTO 0);
    VARIABLE sub_temp : signed(15 DOWNTO 0);
    VARIABLE in0 : signed(15 DOWNTO 0);
    VARIABLE add_cast : signed(48 DOWNTO 0);
    VARIABLE cast : signed(32 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(15 DOWNTO 0);
    VARIABLE mul_temp : signed(48 DOWNTO 0);
    VARIABLE add_cast_0 : signed(47 DOWNTO 0);
    VARIABLE add_cast_1 : signed(48 DOWNTO 0);
    VARIABLE add_temp : signed(48 DOWNTO 0);
  BEGIN
    IF Data_Type_Conversion_out1 <= to_signed(-16#5000#, 16) THEN 
      k := to_unsigned(16#0#, 4);
    ELSIF Data_Type_Conversion_out1 >= to_signed(16#5000#, 16) THEN 
      k := to_unsigned(16#A#, 4);
    ELSE 
      sub_temp := Data_Type_Conversion_out1 - to_signed(-16#5000#, 16);
      k := unsigned(sub_temp(15 DOWNTO 12));
    END IF;
    IF (Data_Type_Conversion_out1 <= to_signed(-16#5000#, 16)) OR (Data_Type_Conversion_out1 >= to_signed(16#5000#, 16)) THEN 
      f := to_unsigned(0, 32);
    ELSE 
      in0 := Data_Type_Conversion_out1 AND to_signed(16#0FFF#, 16);
      f := unsigned(in0(11 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0');
    END IF;
    dout_low := LUT_data(to_integer(k));
    IF k = to_unsigned(16#A#, 4) THEN 
      NULL;
    ELSE 
      k := k + to_unsigned(16#1#, 4);
    END IF;
    add_cast := resize(dout_low & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 49);
    cast := signed(resize(f, 33));
    sub_temp_0 := LUT_data(to_integer(k)) - dout_low;
    mul_temp := cast * sub_temp_0;
    add_cast_0 := mul_temp(47 DOWNTO 0);
    add_cast_1 := resize(add_cast_0, 49);
    add_temp := add_cast + add_cast_1;
    LUT_out1 <= add_temp(47 DOWNTO 32);
  END PROCESS LUT_output;


  Divide_output : PROCESS (Constant1_out1, In3_signed)
    VARIABLE div_temp2 : signed(16 DOWNTO 0);
    VARIABLE cast1 : signed(16 DOWNTO 0);
  BEGIN
    IF Constant1_out1 = to_unsigned(16#0000#, 16) THEN 
      IF In3_signed < to_signed(16#0000#, 16) THEN 
        Divide_out1 <= to_signed(-16#8000#, 16);
      ELSE 
        Divide_out1 <= to_signed(16#7FFF#, 16);
      END IF;
    ELSE 
      cast1 := signed(resize(Constant1_out1, 17));
      div_temp2 := resize(In3_signed, 17) / cast1;
      IF (div_temp2(16) = '0') AND (div_temp2(15) /= '0') THEN 
        Divide_out1 <= X"7FFF";
      ELSIF (div_temp2(16) = '1') AND (div_temp2(15) /= '1') THEN 
        Divide_out1 <= X"8000";
      ELSE 
        Divide_out1 <= div_temp2(15 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Divide_output;


  Data_Type_Conversion1_out1 <= Divide_out1(3 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  LUT1_output : PROCESS (Data_Type_Conversion1_out1)
    VARIABLE dout_low1 : signed(15 DOWNTO 0);
    VARIABLE k1 : unsigned(3 DOWNTO 0);
    VARIABLE f1 : unsigned(31 DOWNTO 0);
    VARIABLE sub_temp1 : signed(15 DOWNTO 0);
    VARIABLE in01 : signed(15 DOWNTO 0);
    VARIABLE add_cast1 : signed(48 DOWNTO 0);
    VARIABLE cast2 : signed(32 DOWNTO 0);
    VARIABLE sub_temp_01 : signed(15 DOWNTO 0);
    VARIABLE mul_temp1 : signed(48 DOWNTO 0);
    VARIABLE add_cast_01 : signed(47 DOWNTO 0);
    VARIABLE add_cast_11 : signed(48 DOWNTO 0);
    VARIABLE add_temp1 : signed(48 DOWNTO 0);
  BEGIN
    IF Data_Type_Conversion1_out1 <= to_signed(-16#5000#, 16) THEN 
      k1 := to_unsigned(16#0#, 4);
    ELSIF Data_Type_Conversion1_out1 >= to_signed(16#5000#, 16) THEN 
      k1 := to_unsigned(16#A#, 4);
    ELSE 
      sub_temp1 := Data_Type_Conversion1_out1 - to_signed(-16#5000#, 16);
      k1 := unsigned(sub_temp1(15 DOWNTO 12));
    END IF;
    IF (Data_Type_Conversion1_out1 <= to_signed(-16#5000#, 16)) OR (Data_Type_Conversion1_out1 >= to_signed(16#5000#, 16)) THEN 
      f1 := to_unsigned(0, 32);
    ELSE 
      in01 := Data_Type_Conversion1_out1 AND to_signed(16#0FFF#, 16);
      f1 := unsigned(in01(11 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0');
    END IF;
    dout_low1 := LUT1_data(to_integer(k1));
    IF k1 = to_unsigned(16#A#, 4) THEN 
      NULL;
    ELSE 
      k1 := k1 + to_unsigned(16#1#, 4);
    END IF;
    add_cast1 := resize(dout_low1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 49);
    cast2 := signed(resize(f1, 33));
    sub_temp_01 := LUT1_data(to_integer(k1)) - dout_low1;
    mul_temp1 := cast2 * sub_temp_01;
    add_cast_01 := mul_temp1(47 DOWNTO 0);
    add_cast_11 := resize(add_cast_01, 49);
    add_temp1 := add_cast1 + add_cast_11;
    LUT1_out1 <= add_temp1(47 DOWNTO 32);
  END PROCESS LUT1_output;


  Product_mul_temp <= LUT_out1 * LUT1_out1;
  Product_out1 <= Product_mul_temp(30 DOWNTO 15);

  Add_stage2_sub_cast <= signed(resize(Add1_out1 & '0' & '0' & '0', 32));
  Add_stage2_sub_cast_1 <= resize(Product_out1, 32);
  Add_op_stage2 <= Add_stage2_sub_cast - Add_stage2_sub_cast_1;

  Constant5_out1 <= to_unsigned(16#0400#, 16);

  Add_stage3_add_cast <= signed(resize(Constant5_out1 & '0' & '0' & '0', 32));
  Add_stage3_add_temp <= Add_op_stage2 + Add_stage3_add_cast;
  Add_out1 <= Add_stage3_add_temp(18 DOWNTO 3);

  Out1 <= std_logic_vector(Add_out1);

END rtl;

